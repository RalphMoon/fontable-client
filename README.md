# Fontable
![fontable 로고](https://github.com/RalphMoon/fontable-client/assets/110374331/d10158db-c056-4e4e-9739-72b81b2a4bd1)
> 폰터블은 손글씨를 otf / ttf 폰트로 변환해주는 폰트 메이킹 웹앱입니다. 복잡하고 전문성이 요구되는 폰트 파일 메이킹을 손글씨로 쉽게 생성해 보세요! 사용자는 폰트 메이킹 프로젝트를 저장해 뒀다가 나중에 작업을 이어서 할 수도 있습니다. 
## 목차
- 동기
- 서비스 화면
- 챌린지 요소
	- 드로잉
	- 폰트 메이킹
- 기술 스택
- 작업 기록
## 동기
> 평소에 저는 수기로 글을 쓰는 것을 좋아합니다. 자신의 손글씨는 다른 글씨체로 쓴 글보다 더 애착이 가기 때문입니다. 하지만 글을 직접 쓰는 것 자체는 꽤 소모적인 일이라고 생각합니다. 그래서 ***타이핑할 때마다 내가 쓴 손글씨가 렌더링되면 어떨까?*** 라는 생각을 하게 되었습니다. 글을 수기로 작성하지 않으면서도 자신의 필체가 보이는 건 분명 가치 있는 서비스라고 생각했습니다. 그렇게 폰터블을 만들게 되었습니다.
## 서비스 화면
<img width="1407" alt="fontable 알파벳 화면" src="https://github.com/RalphMoon/fontable-client/assets/110374331/87a0fff2-51d5-4a3d-8791-d70a651c29d6">
<img width="1419" alt="fontable 드로잉 상세화면" src="https://github.com/RalphMoon/fontable-client/assets/110374331/97a5b05c-fbc3-4441-99fa-009d92afb6ad">
<img width="1112" alt="Ralph Sans 섪치" src="https://github.com/RalphMoon/fontable-client/assets/110374331/998edc70-c8f6-4ce7-8289-e666a078da1c">

![Hello World](https://github.com/RalphMoon/fontable-client/assets/110374331/d4698870-8cf4-42f4-99d3-dc21289b679f)

## 챌린지 요소
### 드로잉
> 유저가 어떻게 하면 손글씨를 최대한 부드럽게 드로잉할 수 있는 지를 고민했습니다. 이 과정에서 라이브러리 사용은 하지 않고 직접 구현하는 것을 자신의 챌린지 요소로 설정하였습니다. 
> 
> 라이브러리의 도움 없이 드로잉 시, 사용 가능했던 그래픽은 SVG와 Canvas API가 있었습니다. 그래서 먼저 두 그래픽 형식을 비교분석하였습니다. 내용은 아래와 같습니다.

| 항목               | SVG                                                                                     | Canvas API                                                                                   |
|-------------------|-----------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------|
| **정의 및 표현 방식** | XML 기반의 벡터 그래픽. DOM 요소로 존재하므로 JavaScript로 쉽게 조작 가능.                  | 비트맵 기반의 그래픽. JavaScript 명령어로 그래픽을 그림. 한 번 그려진 그래픽은 다시 조작하기 어려움. |
| **퍼포먼스**         | 복잡한 그래픽이나 많은 수의 객체를 다룰 때 느려질 수 있음.                                   | 복잡한 애니메이션이나 많은 수의 객체를 빠르게 렌더링 가능.                                        |
| **상호 작용성**       | SVG 요소는 DOM의 일부이므로 이벤트 핸들러나 CSS 스타일링이 쉽다.                             | 픽셀 단위로 그림을 그리기 때문에 상호 작용을 위한 추가 로직이 필요하다.                           |
| **확장성**           | 벡터 기반이므로 확대/축소 시에도 품질 손실이 없다.                                           | 확대/축소 시 품질 손실이 발생할 수 있다.                                                        |
| **적용**             | 폰트 제작과 같은 정밀한 작업이나, 개별 객체에 상호 작용이 필요한 경우에 적합.                | 드로잉 어플리케이션에서 실시간으로 많은 양의 그래픽을 빠르게 렌더링해야 하는 경우에 적합.          |
| **컴포넌트화**       | SVG는 DOM 요소로 존재하므로 리액트 컴포넌트로 쉽게 분리하고 재사용할 수 있다. SVG 요소들은 JSX에서 직접 표현 가능하다. | Canvas는 하나의 `<canvas>` 요소 내에서 그려지므로 컴포넌트화하기가 복잡하다. 그림 그리는 로직을 컴포넌트로 분리하는 것은 어려울 수 있다. |
| **상태 관리**         | SVG 요소는 리액트의 상태와 쉽게 연동할 수 있다. 상태 변화에 따라 SVG 요소를 업데이트하는 것이 자연스럽다. | Canvas는 상태 변화에 따른 렌더링 로직을 직접 구현해야 한다. 상태 변화 시 전체 캔버스를 다시 그려야 할 수도 있다. |
| **퍼포먼스 최적화**   | 리액트의 Virtual DOM과 연동되므로, 변화가 있는 부분만 업데이트할 수 있다. 하지만 많은 수의 SVG 요소가 있을 때는 성능 이슈가 발생할 수 있다. | Canvas는 Virtual DOM과 연동되지 않는다. 따라서, 렌더링 최적화를 위한 추가적인 로직이 필요하다. |
| **스타일링 및 애니메이션** | CSS나 JavaScript를 사용한 스타일링 및 애니메이션이 가능하다. 리액트와의 통합이 쉽다. | Canvas는 스타일링 및 애니메이션을 위한 별도의 로직이 필요하다. CSS를 직접 사용할 수 없다. |
| **이벤트 핸들링**     | SVG 요소는 DOM의 일부이므로 리액트의 이벤트 핸들링 시스과 자연스럽게 통합된다. | Canvas에서의 이벤트 핸들링은 추가적인 로직이 필요하다. 특정 그래픽 요소에 이벤트를 연결하기 위해 좌표 계산 등의 로직이 필요하다. |

> 물론 성능 면에서는 Canvas API를 채택하는 것이 맞아 보였습니다. 하지만 폰트를 만들 때에 무엇보다 중요한 건 글리프(글자 모양)이 깔끔하게 렌더링되는 것이라고 생각했습니다. 그래서 Canvas API 보단 SVG를 채택하였습니다.
> 
> 
> [현재 어플리케이션에서 SVG로 드로잉을 구현한게, *React의 성능적인 측면에서 문제가 없다, 혹은 문제가 있지만 미미하다* 라는 당위성을 모색]
### 폰트 메이킹
| 특징 | 클라이언트                                                                                                                                                                    | 서버 ✅ |
| ---- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------- |
| 장점 | 1. 즉시 폰트를 생성하면 사용자에게 즉각적인 피드백을 제공할 수 있음 | 1. 일관된 성능을 제공할 수 있으며, 클라이언트의 부하를 줄일 수 있음 <br /> 2. 서버에서 처리하면 이러한 데이터 전송량을 줄일 수 있음 <br /> 3. 필요에 따라 서버 자원을 확장하여 처리 능력을 증가시킬 수 있음 |
| 단점 | 1. 사용자의 장치 성능에 따라 처리 속도가 달라질 수 있음. <br /> 2. 클라이언트에서 폰트 생성 로직을 노출하는 것은 보안 리스크가 될 수 있음 <br /> |         |
> 폰트를 생성하는 것이 비즈니스 핵심 로직인만큼, 해당 로직을 클라이언트에서 처리할 지 서버에서 처리할 지 고민이 많았습니다. 그래서 먼저 각각의 장단점을 비교 분석하였습니다. 그 결과 클라이언트에서의 부하를 줄이고, 비즈니스 로직을 노출시켜 보안 리스크를 발생시킬 가능성을 줄이기 위해 서버에서 폰트 생성을 채택하였습니다. 

## 기술 스택
- JavaScript
- React
- Vite
- React-query
- Jotai
- Node.js
- opentype.js 
- firebase auth
